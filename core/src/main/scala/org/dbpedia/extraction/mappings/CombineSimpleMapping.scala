package org.dbpedia.extraction.mappings

import org.dbpedia.extraction.annotations.{AnnotationType, SoftwareAgentAnnotation}
import org.dbpedia.extraction.config.provenance.{DBpediaDatasets, Dataset, ExtractorRecord}
import org.dbpedia.extraction.dataparser.StringParser
import org.dbpedia.extraction.ontology.{Ontology, OntologyProperty}
import org.dbpedia.extraction.transform.{Quad, QuadBuilder}
import org.dbpedia.extraction.util.Language
import org.dbpedia.extraction.wikiparser.{Node, TemplateNode}

import scala.language.reflectiveCalls

/**
  * Created by chile on 15.10.17.
  */
@SoftwareAgentAnnotation(classOf[CombineSimpleMapping], AnnotationType.Extractor)
class CombineSimpleMapping (
                           ontologyProperty : OntologyProperty,
                           val templateProperties: scala.collection.Set[String], // CreateMappingStats requires these to be public
                           delineator : String,
                           context : {
                             def redirects : Redirects  // redirects required by DateTimeParser
                             def ontology: Ontology
                             def language : Language
                           }
                         )
  extends PropertyMapping{
  private val stringType = context.ontology.datatypes("xsd:string")
  private val qb = QuadBuilder(context.language, DBpediaDatasets.OntologyPropertiesLiterals, ontologyProperty, stringType)
  /**
    * Datasets generated by this extractor. Used for serialization. If a mapping implementation
    * does not return all datasets it produces, serialization may fail.
    */
  override val datasets: Set[Dataset] = Set(DBpediaDatasets.OntologyPropertiesLiterals)
  /**
    * @param node       The source node
    * @param subjectUri The subject URI of the generated triples
    * @return A graph holding the extracted data
    */
  override def extract(node: TemplateNode, subjectUri: String): Seq[Quad] = {
    var res = ""
    val parseResults = for (
      templateProperty <- templateProperties;
      property <- node.property(templateProperty);
      parseResult <- StringParser.parseWithProvenance(property)
    ) yield {
      res += delineator + parseResult.value
      parseResult
    }

    //set metadata
    qb.setNodeRecord(node.getNodeRecord)
    qb.setExtractor(ExtractorRecord(
      this.softwareAgentAnnotation,
      parseResults.flatMap(p => p.provenance).toSeq,
      Some(parseResults.size),
      Some(templateProperties.reduce((t1, t2) => t1 + "," + t2)),
      Some(node.title),
      node.containedTemplateNames()
    ))
    //set values
    qb.setSubject(subjectUri)
    qb.setValue(res.substring(delineator.length))
    qb.setSourceUri(node.sourceIri)
    Seq(qb.getQuad)
  }
}
